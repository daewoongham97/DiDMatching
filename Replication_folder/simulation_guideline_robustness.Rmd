---
title: "Simulation to assess varying coefficients and guideline"
output:
  pdf_document: default
  html_document: default
editor_options:
  chunk_output_type: console
---

This runs a small simulation where we have varying beta_theta over time.
We actually conduct the matching analysis and compare it to the empirical to see how our guideline works when it is technically misspecified.

In particular, this document produces Figure 3 and Table 2.


**NOTE** This script conversion is incomplete.  It would be nice to update the oracle to implement the matrix math as given.


```{r}
source( here::here( "data_simulator.R" ) )
source( here::here( "DiD_matching_func.R" ) )
source( here::here( "oracle_bias_calculators.R" ) )
K = 1000

beta_theta_1 = 1.5; beta_theta_0 = c(1, 0.75, 0.50)
mu_theta_1 = 2; mu_theta_0 = 1
mu_x_1 = 3
mu_x_0 = 1.5
beta_x_1 = 0.9
beta_x_0 = c( 1.2, 0.8, 1.0 )
sig_x = 1
sig_theta = 1; sigma_pre = 1.3; sigma_post = 1; p = 0.2; t = 3; N = 20000;
rho = 0.5

# boundary
#sigma_pre = 1.347 (the exact decision boundary point)
sigma_pre_tests = c(1, 1.2, 1.25, 1.3, 1.33, 1.36, 1.4, 1.6, 1.7)



### let's first calculate the theoretical biases under these scenarios
### using our formula in the paper ### (green line in Figure 3)
true_diffs = vector()
bias_naive = vector()
bias_match = vector()
for (j in 1:length(sigma_pre_tests)) {
    
    biases = calculate_truth_varying( beta_theta_1, beta_theta_0,
                             beta_x_1, beta_x_0,
                             mu_theta_1, mu_theta_0,
                             mu_x_1, mu_x_0,
                             sig_theta = sig_theta, sig_x = sig_x,
                             sigma_pre = sigma_pre_tests[[j]], 
                             sigma_post = sigma_post,
                             p = p, num_pre = t, rho = rho )
        

        
        
    sigma_pre = sigma_pre_tests[j]
    truth = c(sigma_pre^2, 
              beta_theta_0[t], beta_theta_1, beta_theta_1 - mean(beta_theta_0),
              beta_theta_0/beta_theta_1, 
              (t*beta_theta_0^2*sig_theta^2)/(t*beta_theta_0^2*sig_theta^2 + sigma_pre^2), 
              mu_theta_1 - mu_theta_0)
    d_t = mu_theta_1 - mu_theta_0
    D_t = beta_theta_1 - mean(beta_theta_0)
    
    bias_naive_DiD = D_t*d_t
    
    
    sigma_thetay = matrix(beta_theta_0*sig_theta^2, nrow = 1)
    sigma_yy = matrix(c(beta_theta_0[1]^2*sig_theta^2 + sigma_pre^2, 
                        beta_theta_0[1]*beta_theta_0[2]*sig_theta^2, 
                        beta_theta_0[1]*beta_theta_0[3]*sig_theta^2,
                        beta_theta_0[1]*beta_theta_0[2]*sig_theta^2,
                        beta_theta_0[2]*beta_theta_0[2]*sig_theta^2 + sigma_pre^2, 
                        beta_theta_0[2]*beta_theta_0[3]*sig_theta^2, 
                        beta_theta_0[1]*beta_theta_0[3]*sig_theta^2,
                        beta_theta_0[3]*beta_theta_0[2]*sig_theta^2,
                        beta_theta_0[3]*beta_theta_0[3]*sig_theta^2 + sigma_pre^2), nrow = 3)
    slopes = matrix(c(beta_theta_0*d_t), ncol = 1)
    
    bias_DiD_matchy = beta_theta_1*(d_t - as.numeric(sigma_thetay%*%solve(sigma_yy)%*%slopes))
    
    bias_naive[j] = abs(bias_naive_DiD)
    bias_match[j] = abs(bias_DiD_matchy)
    
    true_diffs[j] = abs(bias_naive_DiD)- abs(bias_DiD_matchy)
}


### this is actual empirically measured ones ### (blue line in Figure 3)
correct_decision = a_tau_xy = a_est_beta0 = a_est_beta1 = a_est_delta_theta = a_est_sig_pre_sq = vector()
for (j in 1:length(sigma_pre_tests)) {
    sigma_pre= sigma_pre_tests[j]
    match = tau_xy = est_beta0 = est_beta1 = est_delta_theta = est_sig_pre_sq = vector()
    for (i in 1:K) {
        df = make_data(N, seed = i, beta_theta_1, beta_theta_0, mu_theta_1, mu_theta_0,
                       sig_theta, sigma_pre, sigma_post, p, t)
        Y_pre = colnames(df)[4:(4+(t-1))]
        Y_post = "Y_post"
        treatment = "treatment"
        result = DiD_matchy_guideline(Y_pre, Y_post, treatment, df)
        match[i] = result$r_theta >= 1 - abs(1 - result$ratio)
        tau_xy[i] = result$est_tau_xy 
        est_beta0[i] = result$est_beta_theta_pre
        est_beta1[i] = result$est_beta_theta_post
        est_delta_theta[i] = result$est_delta_theta
        est_sig_pre_sq[i] = result$est_sig_pre
    }
    correct_decision[j] = mean(match)
    a_tau_xy[j] = mean(tau_xy)
    a_est_beta0[j] = mean(est_beta0)
    a_est_beta1[j] = mean(est_beta1)
    a_est_delta_theta[j] = mean(est_delta_theta)
    a_est_sig_pre_sq[j] = mean(est_sig_pre_sq)
    a_tau_xy[j] = mean(tau_xy)
    
    print(j)
}
```


```{r}
a_tau_xy; true_diffs

a_est_beta0; beta_theta_0
a_est_beta1; beta_theta_1
a_est_delta_theta; mu_theta_1 - mu_theta_0
a_est_sig_pre_sq; sigma_pre_tests^2

```



## plotting
```{r}
library(ggplot2); library(latex2exp); library(gridExtra); library(ggpubr)

# Figure specifications


s = 5
w = 50
s2 = 5
a1 = 15
a2 = 20
boundary = 1.347^2
plot_df = data.frame(sigma_pre = sigma_pre_tests^2, correct_decision, a_tau_xy, true_diffs)

save(plot_df, file = "~/Downloads/plot_df")

# left panel of Figure 3
plot_1 = ggplot(data = plot_df, aes(x = sigma_pre, y = correct_decision)) + 
    geom_point(size = 2) + 
    geom_line(size = 2) + xlab(TeX("$\\sigma_{E}^2$")) + 
    ylab("Proportion Match") + 
    geom_vline(xintercept=boundary,linetype= "dotted", size = 2, col = "red") + 
    theme(axis.text=element_text(size=a1), axis.title=element_text(size=a2,face="bold"), 
          panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
          panel.background = element_blank(), axis.line = element_line(colour = "black"), 
          plot.title = element_text(size = a2, face = "bold"), axis.title.x = element_text(vjust=-0.5))

plot2_df = data.frame(sigma_pre = c(plot_df$sigma_pre, plot_df$sigma_pre),
                      difference = c(plot_df$a_tau_xy, 
                                     plot_df$true_diffs), 
                      group = factor(rep(c("Estimated Difference", "True Difference"), each = nrow(plot_df))))

# right panel of figure 3
plot_2 = ggplot(data = plot2_df, aes(x = sigma_pre, y = difference, col = group)) + 
    geom_point(size = 2) + 
    geom_line(size = 2) + xlab(TeX("$\\sigma_{E}^2$")) + 
    ylab("Bias of No Match - Bias of Match") +
    scale_color_manual(values = c("Blue", "Dark Green")) + 
    geom_vline(xintercept=boundary,linetype= "dotted", size = 2, col = "red") +  
    theme(axis.text=element_text(size=a1), axis.title=element_text(size=a2,face="bold"), 
          panel.grid.major = element_blank(), legend.position= "top", legend.title=element_blank(),
          legend.text=element_text(size=a1), panel.grid.minor = element_blank(), 
          panel.background = element_blank(), axis.line = element_line(colour = "black"), 
          plot.title = element_text(size = a2, face = "bold"), axis.title.x = element_text(vjust=-0.5)) 

fig_3 = ggarrange(plot_1, plot_2, nrow = 1)

fig_3
```



